// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/ethereum/go-ethereum/ethclient"
	"gitlab.com/TitanInd/hashrouter/api"
	"gitlab.com/TitanInd/hashrouter/config"
	"gitlab.com/TitanInd/hashrouter/connections"
	"gitlab.com/TitanInd/hashrouter/contractmanager"
	"gitlab.com/TitanInd/hashrouter/events"
	"gitlab.com/TitanInd/hashrouter/interfaces"
	"gitlab.com/TitanInd/hashrouter/lib"
	"gitlab.com/TitanInd/hashrouter/mining"
	"go.uber.org/zap"
)

// Injectors from main.go:

func InitApp() (*App, error) {
	configConfig, err := config.NewConfig()
	if err != nil {
		return nil, err
	}
	iEventManager := events.NewEventManager()
	miningController := provideMiningController(configConfig, iEventManager)
	connectionsController := provideConnectionController(configConfig, miningController, iEventManager)
	server := provideServer(configConfig, connectionsController)
	client, err := provideEthClient(configConfig)
	if err != nil {
		return nil, err
	}
	sugaredLogger, err := lib.NewLogger()
	if err != nil {
		return nil, err
	}
	sellerContractManager := provideSellerContractManager(configConfig, iEventManager, client, sugaredLogger)
	app := provideApp(connectionsController, miningController, server, sellerContractManager)
	return app, nil
}

// main.go:

const VERSION = "0.01"

func main() {
	app, err := InitApp()
	if err != nil {
		panic(err)
	}
	app.Run()
}

type App struct {
	connectionsController *connections.ConnectionsController
	miningController      *mining.MiningController
	server                *api.Server
	sellerManager         *contractmanager.SellerContractManager
}

func (a *App) Run() {
	ctx, _ := context.WithCancel(context.Background())
	a.connectionsController.Run()
	a.miningController.Run()
	a.sellerManager.Run(ctx)
	a.server.Run(ctx)
	<-ctx.Done()
}

func provideMiningController(cfg *config.Config, em interfaces.IEventManager) *mining.MiningController {
	return mining.NewMiningController(cfg.PoolUser, cfg.PoolPassword, em)
}

func provideConnectionController(cfg *config.Config, mc *mining.MiningController, em interfaces.IEventManager) *connections.ConnectionsController {
	return connections.NewConnectionsController(cfg.PoolAddress, mc, em)
}

func provideServer(cfg *config.Config, cc *connections.ConnectionsController) *api.Server {
	return api.NewServer(cfg.WebAddress, cc)
}

func provideEthClient(cfg *config.Config) (*ethclient.Client, error) {
	return contractmanager.NewEthClient(cfg.EthNodeAddress)
}

func provideSellerContractManager(cfg *config.Config, em interfaces.IEventManager, ethClient *ethclient.Client, logger *zap.SugaredLogger) *contractmanager.SellerContractManager {
	return contractmanager.NewSellerContractManager(logger, em, ethClient, cfg.ContractAddress)
}

func provideApp(
	connectionsController *connections.ConnectionsController,
	miningController *mining.MiningController,
	server *api.Server,
	sellerManager *contractmanager.SellerContractManager,
) *App {
	return &App{
		connectionsController: connectionsController,
		miningController:      miningController,
		server:                server,
		sellerManager:         sellerManager,
	}
}
