// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/google/wire"
	"gitlab.com/TitanInd/hashrouter/api"
	"gitlab.com/TitanInd/hashrouter/app"
	"gitlab.com/TitanInd/hashrouter/config"
	"gitlab.com/TitanInd/hashrouter/contractmanager"
	"gitlab.com/TitanInd/hashrouter/contractmanager/blockchain"
	"gitlab.com/TitanInd/hashrouter/data"
	"gitlab.com/TitanInd/hashrouter/eventbus"
	"gitlab.com/TitanInd/hashrouter/interfaces"
	"gitlab.com/TitanInd/hashrouter/lib"
	"gitlab.com/TitanInd/hashrouter/miner"
	"gitlab.com/TitanInd/hashrouter/tcpserver"
	"os"
)

// Injectors from main.go:

//TODO: make sure all providers initialized
func InitApp() (*app.App, error) {
	config, err := provideConfig()
	if err != nil {
		return nil, err
	}
	iLogger, err := provideLogger(config)
	if err != nil {
		return nil, err
	}
	tcpServer := provideTCPServer(config, iLogger)
	minerRepo := miner.NewMinerRepo()
	minerController := provideMinerController(config, iLogger, minerRepo)
	server := provideServer(config, iLogger, minerController)
	iValidatorsService := provideHashrateCalculator()
	iConnectionsService := provideConnectionsService()
	client, err := provideEthClient(config)
	if err != nil {
		return nil, err
	}
	iBlockchainGateway, err := blockchain.NewBlockchainGateway(client)
	if err != nil {
		return nil, err
	}
	iContractFactory := provideContractFactory()
	v := data.NewInMemoryDataStore()
	v2 := data.NewTransactionsChannel()
	iContractsRepository := provideContractsRepository(iLogger, v, v2)
	iContractsGateway := provideContractsGateway(iContractsRepository)
	iContractsService := contractmanager.NewContractsService(iLogger, iValidatorsService, iConnectionsService, iBlockchainGateway, iContractFactory, iContractsGateway, config)
	iEventManager := eventbus.NewEventBus()
	iBlockchainWallet := blockchain.NewBlockchainWallet(config)
	nodeOperator, err := contractmanager.NewNodeOperator(config, iBlockchainWallet)
	if err != nil {
		return nil, err
	}
	contractManager, err := provideSellerContractManager(iContractsService, config, iEventManager, iContractFactory, client, iLogger, nodeOperator, iBlockchainWallet)
	if err != nil {
		return nil, err
	}
	appApp := &app.App{
		TCPServer:       tcpServer,
		MinerController: minerController,
		Server:          server,
		ContractManager: contractManager,
		Logger:          iLogger,
	}
	return appApp, nil
}

func initContractModel() (*contractmanager.Contract, error) {
	config, err := provideConfig()
	if err != nil {
		return nil, err
	}
	iLogger, err := provideLogger(config)
	if err != nil {
		return nil, err
	}
	client, err := provideEthClient(config)
	if err != nil {
		return nil, err
	}
	iBlockchainGateway, err := blockchain.NewBlockchainGateway(client)
	if err != nil {
		return nil, err
	}
	v := data.NewInMemoryDataStore()
	v2 := data.NewTransactionsChannel()
	iContractsRepository := provideContractsRepository(iLogger, v, v2)
	iContractsGateway := provideContractsGateway(iContractsRepository)
	contract := provideContractModel(iLogger, iBlockchainGateway, iContractsGateway)
	return contract, nil
}

// main.go:

const VERSION = "0.01"

func main() {
	appInstance, err := InitApp()
	if err != nil {
		panic(err)
	}

	appInstance.Run()
}

var dataSet = wire.NewSet(data.NewTransactionsChannel, data.NewInMemoryDataStore)

var networkSet = wire.NewSet(provideTCPServer, provideServer)

var protocolSet = wire.NewSet(miner.NewMinerRepo, provideMinerController, eventbus.NewEventBus, provideConnectionsService)

var contractsSet = wire.NewSet(provideContractsRepository, blockchain.NewBlockchainWallet, provideEthClient, blockchain.NewBlockchainGateway, provideContractFactory, provideContractsGateway, contractmanager.NewNodeOperator, contractmanager.NewContractsService, provideSellerContractManager)

var hashrateCalculationSet = wire.NewSet(provideHashrateCalculator)

func provideContractsRepository(logger interfaces.ILogger, dataStore data.Store, transactionsChannel data.TransactionsChannel) contractmanager.IContractsRepository {
	return data.NewInMemoryRepository[interfaces.IContractModel](logger, dataStore, transactionsChannel)
}

func provideContractsGateway(repo contractmanager.IContractsRepository) interfaces.IContractsGateway {
	return contractmanager.NewContractsGateway(repo)
}

func provideConnectionsService() interfaces.IConnectionsService {
	return nil
}

func provideHashrateCalculator() interfaces.IValidatorsService {

	return nil
}

func provideMinerController(cfg *config.Config, l interfaces.ILogger, repo *miner.MinerRepo) *miner.MinerController {
	return miner.NewMinerController(cfg.Pool.Address, cfg.Pool.User, cfg.Pool.Password, repo, l)
}

func provideTCPServer(cfg *config.Config, l interfaces.ILogger) *tcpserver.TCPServer {
	return tcpserver.NewTCPServer(cfg.Proxy.Address, l)
}

func provideServer(cfg *config.Config, l interfaces.ILogger, ph *miner.MinerController) *api.Server {
	return api.NewServer(cfg.Web.Address, l, ph)
}

func provideEthClient(cfg *config.Config) (*ethclient.Client, error) {
	return contractmanager.NewEthClient(cfg.EthNode.Address)
}

func provideSellerContractManager(
	contractsService interfaces.IContractsService,
	cfg *config.Config,
	em interfaces.IEventManager,
	factory interfaces.IContractFactory,
	ethClient *ethclient.Client,
	logger interfaces.ILogger,
	nodeOperator *contractmanager.NodeOperator,
	wallet interfaces.IBlockchainWallet,
) (interfaces.ContractManager, error) {
	return contractmanager.NewContractManager(context.TODO(), contractsService, logger, cfg, em, factory, ethClient, nodeOperator, wallet)
}

func provideLogger(cfg *config.Config) (interfaces.ILogger, error) {
	return lib.NewLogger(cfg.Log.Syslog)
}

func provideConfig() (*config.Config, error) {
	var cfg config.Config
	return &cfg, config.LoadConfig(&cfg, &os.Args)
}

func provideContractFactory() interfaces.IContractFactory {
	return &ContractFactory{}
}

type ContractFactory struct {
}

func (*ContractFactory) CreateContract(
	IsSeller bool,
	ID string,
	State string,
	Buyer string,
	Price int,
	Limit int,
	Speed int,
	Length int,
	StartingBlockTimestamp int,
	Dest string,
) (interfaces.IContractModel, error) {
	model, err := initContractModel()

	if err != nil {
		return model, err
	}

	model.IsSeller = IsSeller
	model.ID = ID
	model.State = State
	model.State = State
	model.Buyer = Buyer
	model.Price = Price
	model.Limit = Limit
	model.Speed = Speed
	model.Length = Length
	model.StartingBlockTimestamp = StartingBlockTimestamp
	model.Dest = Dest

	return model, err
}

func provideContractModel(logger interfaces.ILogger, ethereumGateway interfaces.IBlockchainGateway, contractsGateway interfaces.IContractsGateway) *contractmanager.Contract {
	return &contractmanager.Contract{
		Logger:           logger,
		EthereumGateway:  ethereumGateway,
		ContractsGateway: contractsGateway,
	}
}
